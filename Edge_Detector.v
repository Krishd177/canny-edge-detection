// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\EdgeDetectionAndOverlayHDL\Edge_Detector.v
// Created: 2023-11-17 13:10:32
// 
// Generated by MATLAB 9.14 and HDL Coder 4.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Edge_Detector
// Source Path: EdgeDetectionAndOverlayHDL/Pixel-Stream HDL Model/Edge Detection/Edge Detector
// Hierarchy Level: 2
// 
// Edge Detector
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Edge_Detector
          (clk,
           reset,
           enb,
           in1_hStart,
           in1_hEnd,
           in1_vStart,
           in1_vEnd,
           in1_valid,
           out1_hStart,
           out1_hEnd,
           out1_vStart,
           out1_vEnd,
           out1_valid);


  input   clk;
  input   reset;
  input   enb;
  input   in1_hStart;
  input   in1_hEnd;
  input   in1_vStart;
  input   in1_vEnd;
  input   in1_valid;
  output  out1_hStart;
  output  out1_hEnd;
  output  out1_vStart;
  output  out1_vEnd;
  output  out1_valid;


  wire LMKhStartOut;
  wire LMKhEndOut;
  wire LMKvStartOut;
  wire LMKvEndOut;
  wire LMKvalidOut;
  wire LMKShiftEnb;
  reg  validOutKernelDelay;
  wire validOutValidKernelDelay;
  reg  [0:9] intdelay_reg;  // ufix1 [10]
  wire [0:9] intdelay_reg_next;  // ufix1 [10]
  wire validOutDelay;
  reg  hStartOutKernelDelay;
  wire hStartOutValidKernelDelay;
  reg  [0:9] intdelay_reg_1;  // ufix1 [10]
  wire [0:9] intdelay_reg_next_1;  // ufix1 [10]
  wire hStartOutDelay;
  wire hsNext;
  reg  hStartOut;
  reg  hEndOutKernelDelay;
  wire hEndOutValidKernelDelay;
  reg  [0:9] intdelay_reg_2;  // ufix1 [10]
  wire [0:9] intdelay_reg_next_2;  // ufix1 [10]
  wire hEndOutDelay;
  wire heNext;
  reg  hEndOut;
  reg  vStartOutKernelDelay;
  wire vStartOutValidKernelDelay;
  reg  [0:9] intdelay_reg_3;  // ufix1 [10]
  wire [0:9] intdelay_reg_next_3;  // ufix1 [10]
  wire vStartOutDelay;
  wire vsNext;
  reg  vStartOut;
  reg  vEndOutKernelDelay;
  wire vEndOutValidKernelDelay;
  reg  [0:9] intdelay_reg_4;  // ufix1 [10]
  wire [0:9] intdelay_reg_next_4;  // ufix1 [10]
  wire vEndOutDelay;
  wire veNext;
  reg  vEndOut;
  reg  validOut;


  LineBuffer u_LineBuffer (.clk(clk),
                           .reset(reset),
                           .enb(enb),
                           .hStartIn(in1_hStart),
                           .hEndIn(in1_hEnd),
                           .vStartIn(in1_vStart),
                           .vEndIn(in1_vEnd),
                           .validIn(in1_valid),
                           .hStartOut(LMKhStartOut),
                           .hEndOut(LMKhEndOut),
                           .vStartOut(LMKvStartOut),
                           .vEndOut(LMKvEndOut),
                           .validOut(LMKvalidOut),
                           .processDataOut(LMKShiftEnb)
                           );

  always @(posedge clk or posedge reset)
    begin : intdelay_process
      if (reset == 1'b1) begin
        validOutKernelDelay <= 1'b0;
      end
      else begin
        if (enb && LMKShiftEnb) begin
          validOutKernelDelay <= LMKvalidOut;
        end
      end
    end



  assign validOutValidKernelDelay = validOutKernelDelay & LMKShiftEnb;



  always @(posedge clk or posedge reset)
    begin : intdelay_1_process
      if (reset == 1'b1) begin
        intdelay_reg[0] <= 1'b0;
        intdelay_reg[1] <= 1'b0;
        intdelay_reg[2] <= 1'b0;
        intdelay_reg[3] <= 1'b0;
        intdelay_reg[4] <= 1'b0;
        intdelay_reg[5] <= 1'b0;
        intdelay_reg[6] <= 1'b0;
        intdelay_reg[7] <= 1'b0;
        intdelay_reg[8] <= 1'b0;
        intdelay_reg[9] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg[0] <= intdelay_reg_next[0];
          intdelay_reg[1] <= intdelay_reg_next[1];
          intdelay_reg[2] <= intdelay_reg_next[2];
          intdelay_reg[3] <= intdelay_reg_next[3];
          intdelay_reg[4] <= intdelay_reg_next[4];
          intdelay_reg[5] <= intdelay_reg_next[5];
          intdelay_reg[6] <= intdelay_reg_next[6];
          intdelay_reg[7] <= intdelay_reg_next[7];
          intdelay_reg[8] <= intdelay_reg_next[8];
          intdelay_reg[9] <= intdelay_reg_next[9];
        end
      end
    end

  assign validOutDelay = intdelay_reg[9];
  assign intdelay_reg_next[0] = validOutValidKernelDelay;
  assign intdelay_reg_next[1] = intdelay_reg[0];
  assign intdelay_reg_next[2] = intdelay_reg[1];
  assign intdelay_reg_next[3] = intdelay_reg[2];
  assign intdelay_reg_next[4] = intdelay_reg[3];
  assign intdelay_reg_next[5] = intdelay_reg[4];
  assign intdelay_reg_next[6] = intdelay_reg[5];
  assign intdelay_reg_next[7] = intdelay_reg[6];
  assign intdelay_reg_next[8] = intdelay_reg[7];
  assign intdelay_reg_next[9] = intdelay_reg[8];



  always @(posedge clk or posedge reset)
    begin : intdelay_2_process
      if (reset == 1'b1) begin
        hStartOutKernelDelay <= 1'b0;
      end
      else begin
        if (enb && LMKShiftEnb) begin
          hStartOutKernelDelay <= LMKhStartOut;
        end
      end
    end



  assign hStartOutValidKernelDelay = hStartOutKernelDelay & LMKShiftEnb;



  always @(posedge clk or posedge reset)
    begin : intdelay_3_process
      if (reset == 1'b1) begin
        intdelay_reg_1[0] <= 1'b0;
        intdelay_reg_1[1] <= 1'b0;
        intdelay_reg_1[2] <= 1'b0;
        intdelay_reg_1[3] <= 1'b0;
        intdelay_reg_1[4] <= 1'b0;
        intdelay_reg_1[5] <= 1'b0;
        intdelay_reg_1[6] <= 1'b0;
        intdelay_reg_1[7] <= 1'b0;
        intdelay_reg_1[8] <= 1'b0;
        intdelay_reg_1[9] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_1[0] <= intdelay_reg_next_1[0];
          intdelay_reg_1[1] <= intdelay_reg_next_1[1];
          intdelay_reg_1[2] <= intdelay_reg_next_1[2];
          intdelay_reg_1[3] <= intdelay_reg_next_1[3];
          intdelay_reg_1[4] <= intdelay_reg_next_1[4];
          intdelay_reg_1[5] <= intdelay_reg_next_1[5];
          intdelay_reg_1[6] <= intdelay_reg_next_1[6];
          intdelay_reg_1[7] <= intdelay_reg_next_1[7];
          intdelay_reg_1[8] <= intdelay_reg_next_1[8];
          intdelay_reg_1[9] <= intdelay_reg_next_1[9];
        end
      end
    end

  assign hStartOutDelay = intdelay_reg_1[9];
  assign intdelay_reg_next_1[0] = hStartOutValidKernelDelay;
  assign intdelay_reg_next_1[1] = intdelay_reg_1[0];
  assign intdelay_reg_next_1[2] = intdelay_reg_1[1];
  assign intdelay_reg_next_1[3] = intdelay_reg_1[2];
  assign intdelay_reg_next_1[4] = intdelay_reg_1[3];
  assign intdelay_reg_next_1[5] = intdelay_reg_1[4];
  assign intdelay_reg_next_1[6] = intdelay_reg_1[5];
  assign intdelay_reg_next_1[7] = intdelay_reg_1[6];
  assign intdelay_reg_next_1[8] = intdelay_reg_1[7];
  assign intdelay_reg_next_1[9] = intdelay_reg_1[8];



  assign hsNext = validOutDelay & hStartOutDelay;



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_process
      if (reset == 1'b1) begin
        hStartOut <= 1'b0;
      end
      else begin
        if (enb) begin
          hStartOut <= hsNext;
        end
      end
    end



  assign out1_hStart = hStartOut;

  always @(posedge clk or posedge reset)
    begin : intdelay_4_process
      if (reset == 1'b1) begin
        hEndOutKernelDelay <= 1'b0;
      end
      else begin
        if (enb && LMKShiftEnb) begin
          hEndOutKernelDelay <= LMKhEndOut;
        end
      end
    end



  assign hEndOutValidKernelDelay = hEndOutKernelDelay & LMKShiftEnb;



  always @(posedge clk or posedge reset)
    begin : intdelay_5_process
      if (reset == 1'b1) begin
        intdelay_reg_2[0] <= 1'b0;
        intdelay_reg_2[1] <= 1'b0;
        intdelay_reg_2[2] <= 1'b0;
        intdelay_reg_2[3] <= 1'b0;
        intdelay_reg_2[4] <= 1'b0;
        intdelay_reg_2[5] <= 1'b0;
        intdelay_reg_2[6] <= 1'b0;
        intdelay_reg_2[7] <= 1'b0;
        intdelay_reg_2[8] <= 1'b0;
        intdelay_reg_2[9] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_2[0] <= intdelay_reg_next_2[0];
          intdelay_reg_2[1] <= intdelay_reg_next_2[1];
          intdelay_reg_2[2] <= intdelay_reg_next_2[2];
          intdelay_reg_2[3] <= intdelay_reg_next_2[3];
          intdelay_reg_2[4] <= intdelay_reg_next_2[4];
          intdelay_reg_2[5] <= intdelay_reg_next_2[5];
          intdelay_reg_2[6] <= intdelay_reg_next_2[6];
          intdelay_reg_2[7] <= intdelay_reg_next_2[7];
          intdelay_reg_2[8] <= intdelay_reg_next_2[8];
          intdelay_reg_2[9] <= intdelay_reg_next_2[9];
        end
      end
    end

  assign hEndOutDelay = intdelay_reg_2[9];
  assign intdelay_reg_next_2[0] = hEndOutValidKernelDelay;
  assign intdelay_reg_next_2[1] = intdelay_reg_2[0];
  assign intdelay_reg_next_2[2] = intdelay_reg_2[1];
  assign intdelay_reg_next_2[3] = intdelay_reg_2[2];
  assign intdelay_reg_next_2[4] = intdelay_reg_2[3];
  assign intdelay_reg_next_2[5] = intdelay_reg_2[4];
  assign intdelay_reg_next_2[6] = intdelay_reg_2[5];
  assign intdelay_reg_next_2[7] = intdelay_reg_2[6];
  assign intdelay_reg_next_2[8] = intdelay_reg_2[7];
  assign intdelay_reg_next_2[9] = intdelay_reg_2[8];



  assign heNext = validOutDelay & hEndOutDelay;



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_1_process
      if (reset == 1'b1) begin
        hEndOut <= 1'b0;
      end
      else begin
        if (enb) begin
          hEndOut <= heNext;
        end
      end
    end



  assign out1_hEnd = hEndOut;

  always @(posedge clk or posedge reset)
    begin : intdelay_6_process
      if (reset == 1'b1) begin
        vStartOutKernelDelay <= 1'b0;
      end
      else begin
        if (enb && LMKShiftEnb) begin
          vStartOutKernelDelay <= LMKvStartOut;
        end
      end
    end



  assign vStartOutValidKernelDelay = vStartOutKernelDelay & LMKShiftEnb;



  always @(posedge clk or posedge reset)
    begin : intdelay_7_process
      if (reset == 1'b1) begin
        intdelay_reg_3[0] <= 1'b0;
        intdelay_reg_3[1] <= 1'b0;
        intdelay_reg_3[2] <= 1'b0;
        intdelay_reg_3[3] <= 1'b0;
        intdelay_reg_3[4] <= 1'b0;
        intdelay_reg_3[5] <= 1'b0;
        intdelay_reg_3[6] <= 1'b0;
        intdelay_reg_3[7] <= 1'b0;
        intdelay_reg_3[8] <= 1'b0;
        intdelay_reg_3[9] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_3[0] <= intdelay_reg_next_3[0];
          intdelay_reg_3[1] <= intdelay_reg_next_3[1];
          intdelay_reg_3[2] <= intdelay_reg_next_3[2];
          intdelay_reg_3[3] <= intdelay_reg_next_3[3];
          intdelay_reg_3[4] <= intdelay_reg_next_3[4];
          intdelay_reg_3[5] <= intdelay_reg_next_3[5];
          intdelay_reg_3[6] <= intdelay_reg_next_3[6];
          intdelay_reg_3[7] <= intdelay_reg_next_3[7];
          intdelay_reg_3[8] <= intdelay_reg_next_3[8];
          intdelay_reg_3[9] <= intdelay_reg_next_3[9];
        end
      end
    end

  assign vStartOutDelay = intdelay_reg_3[9];
  assign intdelay_reg_next_3[0] = vStartOutValidKernelDelay;
  assign intdelay_reg_next_3[1] = intdelay_reg_3[0];
  assign intdelay_reg_next_3[2] = intdelay_reg_3[1];
  assign intdelay_reg_next_3[3] = intdelay_reg_3[2];
  assign intdelay_reg_next_3[4] = intdelay_reg_3[3];
  assign intdelay_reg_next_3[5] = intdelay_reg_3[4];
  assign intdelay_reg_next_3[6] = intdelay_reg_3[5];
  assign intdelay_reg_next_3[7] = intdelay_reg_3[6];
  assign intdelay_reg_next_3[8] = intdelay_reg_3[7];
  assign intdelay_reg_next_3[9] = intdelay_reg_3[8];



  assign vsNext = validOutDelay & vStartOutDelay;



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_2_process
      if (reset == 1'b1) begin
        vStartOut <= 1'b0;
      end
      else begin
        if (enb) begin
          vStartOut <= vsNext;
        end
      end
    end



  assign out1_vStart = vStartOut;

  always @(posedge clk or posedge reset)
    begin : intdelay_8_process
      if (reset == 1'b1) begin
        vEndOutKernelDelay <= 1'b0;
      end
      else begin
        if (enb && LMKShiftEnb) begin
          vEndOutKernelDelay <= LMKvEndOut;
        end
      end
    end



  assign vEndOutValidKernelDelay = vEndOutKernelDelay & LMKShiftEnb;



  always @(posedge clk or posedge reset)
    begin : intdelay_9_process
      if (reset == 1'b1) begin
        intdelay_reg_4[0] <= 1'b0;
        intdelay_reg_4[1] <= 1'b0;
        intdelay_reg_4[2] <= 1'b0;
        intdelay_reg_4[3] <= 1'b0;
        intdelay_reg_4[4] <= 1'b0;
        intdelay_reg_4[5] <= 1'b0;
        intdelay_reg_4[6] <= 1'b0;
        intdelay_reg_4[7] <= 1'b0;
        intdelay_reg_4[8] <= 1'b0;
        intdelay_reg_4[9] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_4[0] <= intdelay_reg_next_4[0];
          intdelay_reg_4[1] <= intdelay_reg_next_4[1];
          intdelay_reg_4[2] <= intdelay_reg_next_4[2];
          intdelay_reg_4[3] <= intdelay_reg_next_4[3];
          intdelay_reg_4[4] <= intdelay_reg_next_4[4];
          intdelay_reg_4[5] <= intdelay_reg_next_4[5];
          intdelay_reg_4[6] <= intdelay_reg_next_4[6];
          intdelay_reg_4[7] <= intdelay_reg_next_4[7];
          intdelay_reg_4[8] <= intdelay_reg_next_4[8];
          intdelay_reg_4[9] <= intdelay_reg_next_4[9];
        end
      end
    end

  assign vEndOutDelay = intdelay_reg_4[9];
  assign intdelay_reg_next_4[0] = vEndOutValidKernelDelay;
  assign intdelay_reg_next_4[1] = intdelay_reg_4[0];
  assign intdelay_reg_next_4[2] = intdelay_reg_4[1];
  assign intdelay_reg_next_4[3] = intdelay_reg_4[2];
  assign intdelay_reg_next_4[4] = intdelay_reg_4[3];
  assign intdelay_reg_next_4[5] = intdelay_reg_4[4];
  assign intdelay_reg_next_4[6] = intdelay_reg_4[5];
  assign intdelay_reg_next_4[7] = intdelay_reg_4[6];
  assign intdelay_reg_next_4[8] = intdelay_reg_4[7];
  assign intdelay_reg_next_4[9] = intdelay_reg_4[8];



  assign veNext = validOutDelay & vEndOutDelay;



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_3_process
      if (reset == 1'b1) begin
        vEndOut <= 1'b0;
      end
      else begin
        if (enb) begin
          vEndOut <= veNext;
        end
      end
    end



  assign out1_vEnd = vEndOut;

  always @(posedge clk or posedge reset)
    begin : reg_rsvd_4_process
      if (reset == 1'b1) begin
        validOut <= 1'b0;
      end
      else begin
        if (enb) begin
          validOut <= validOutDelay;
        end
      end
    end



  assign out1_valid = validOut;

endmodule  // Edge_Detector

