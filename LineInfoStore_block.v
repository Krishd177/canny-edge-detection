// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\EdgeDetectionAndOverlayHDL\LineInfoStore_block.v
// Created: 2023-11-17 13:10:32
// 
// Generated by MATLAB 9.14 and HDL Coder 4.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: LineInfoStore_block
// Source Path: EdgeDetectionAndOverlayHDL/Pixel-Stream HDL Model/Edge Detection/Edge Detector/LineBuffer/LineInfoStore
// Hierarchy Level: 4
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module LineInfoStore_block
          (clk,
           reset,
           enb,
           hStartIn,
           hEndIn,
           vEndIn,
           validIn,
           dumpControl,
           preProcess,
           PrePadFlag,
           OnLineFlag,
           PostPadFlag,
           DumpingFlag,
           BlankingFlag,
           hStartOut,
           hEndOut,
           vEndOut,
           validOut);


  input   clk;
  input   reset;
  input   enb;
  input   hStartIn;
  input   hEndIn;
  input   vEndIn;
  input   validIn;
  input   dumpControl;
  input   preProcess;
  output  PrePadFlag;
  output  OnLineFlag;
  output  PostPadFlag;
  output  DumpingFlag;
  output  BlankingFlag;
  output  hStartOut;
  output  hEndOut;
  output  vEndOut;
  output  validOut;


  wire validTemp1;
  wire validTemp2;
  reg  [0:1] intdelay_reg;  // ufix1 [2]
  wire [0:1] intdelay_reg_next;  // ufix1 [2]
  wire hStartFirstTap;
  reg  hStartFinalTap;
  reg  hEndFirstTap;
  reg  hEndSecondTap;
  reg  [0:1] intdelay_reg_1;  // ufix1 [2]
  wire [0:1] intdelay_reg_next_1;  // ufix1 [2]
  wire hEndFinalTap;
  reg  [0:1] intdelay_reg_2;  // ufix1 [2]
  wire [0:1] intdelay_reg_next_2;  // ufix1 [2]
  reg  [0:2] intdelay_reg_3;  // ufix1 [3]
  wire [0:2] intdelay_reg_next_3;  // ufix1 [3]
  wire validFirstTap;
  wire validGate1;
  wire notPreProcess;
  wire validGate2;
  wire validGate3;
  wire validGate4;


  assign validTemp1 = validIn | dumpControl;



  assign validTemp2 = hEndIn | validTemp1;



  always @(posedge clk or posedge reset)
    begin : intdelay_process
      if (reset == 1'b1) begin
        intdelay_reg[0] <= 1'b0;
        intdelay_reg[1] <= 1'b0;
      end
      else begin
        if (enb && validTemp2) begin
          intdelay_reg[0] <= intdelay_reg_next[0];
          intdelay_reg[1] <= intdelay_reg_next[1];
        end
      end
    end

  assign hStartFirstTap = intdelay_reg[1];
  assign intdelay_reg_next[0] = hStartIn;
  assign intdelay_reg_next[1] = intdelay_reg[0];



  assign PrePadFlag = hStartFirstTap;

  always @(posedge clk or posedge reset)
    begin : intdelay_1_process
      if (reset == 1'b1) begin
        hStartFinalTap <= 1'b0;
      end
      else begin
        if (enb && validTemp2) begin
          hStartFinalTap <= hStartFirstTap;
        end
      end
    end



  assign OnLineFlag = hStartFinalTap;

  always @(posedge clk or posedge reset)
    begin : reg_rsvd_process
      if (reset == 1'b1) begin
        hEndFirstTap <= 1'b0;
      end
      else begin
        if (enb && validTemp2) begin
          hEndFirstTap <= hEndIn;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : intdelay_2_process
      if (reset == 1'b1) begin
        hEndSecondTap <= 1'b0;
      end
      else begin
        if (enb && validTemp2) begin
          hEndSecondTap <= hEndFirstTap;
        end
      end
    end



  assign PostPadFlag = hEndSecondTap;

  assign DumpingFlag = hEndFirstTap;

  always @(posedge clk or posedge reset)
    begin : intdelay_3_process
      if (reset == 1'b1) begin
        intdelay_reg_1[0] <= 1'b0;
        intdelay_reg_1[1] <= 1'b0;
      end
      else begin
        if (enb && validTemp2) begin
          intdelay_reg_1[0] <= intdelay_reg_next_1[0];
          intdelay_reg_1[1] <= intdelay_reg_next_1[1];
        end
      end
    end

  assign hEndFinalTap = intdelay_reg_1[1];
  assign intdelay_reg_next_1[0] = hEndSecondTap;
  assign intdelay_reg_next_1[1] = intdelay_reg_1[0];



  assign BlankingFlag = hEndFinalTap;

  assign hStartOut = hStartFinalTap;

  assign hEndOut = hEndSecondTap;

  always @(posedge clk or posedge reset)
    begin : intdelay_4_process
      if (reset == 1'b1) begin
        intdelay_reg_2[0] <= 1'b0;
        intdelay_reg_2[1] <= 1'b0;
      end
      else begin
        if (enb && validTemp2) begin
          intdelay_reg_2[0] <= intdelay_reg_next_2[0];
          intdelay_reg_2[1] <= intdelay_reg_next_2[1];
        end
      end
    end

  assign vEndOut = intdelay_reg_2[1];
  assign intdelay_reg_next_2[0] = vEndIn;
  assign intdelay_reg_next_2[1] = intdelay_reg_2[0];



  always @(posedge clk or posedge reset)
    begin : intdelay_5_process
      if (reset == 1'b1) begin
        intdelay_reg_3[0] <= 1'b0;
        intdelay_reg_3[1] <= 1'b0;
        intdelay_reg_3[2] <= 1'b0;
      end
      else begin
        if (enb && validTemp2) begin
          intdelay_reg_3[0] <= intdelay_reg_next_3[0];
          intdelay_reg_3[1] <= intdelay_reg_next_3[1];
          intdelay_reg_3[2] <= intdelay_reg_next_3[2];
        end
      end
    end

  assign validFirstTap = intdelay_reg_3[2];
  assign intdelay_reg_next_3[0] = validIn;
  assign intdelay_reg_next_3[1] = intdelay_reg_3[0];
  assign intdelay_reg_next_3[2] = intdelay_reg_3[1];



  assign validGate1 = hStartFirstTap & validFirstTap;



  assign notPreProcess =  ~ preProcess;



  assign validGate2 = validFirstTap & notPreProcess;



  assign validGate3 = validGate1 | validGate2;



  assign validGate4 = hStartFinalTap | validGate3;



  assign validOut = validGate4;

endmodule  // LineInfoStore_block

